<!DOCTYPE html>
<html lang="en">
	<head>
    	<meta charset="utf-8">
		<title>Delete Key</title>
    	<style>
	
			.node {
				cursor: pointer;
			}
 
			.node circle {
	  			fill: #fff;
	  			stroke: steelblue;
	  			stroke-width: 3px;
			}
 
			.node text {
	  			font: 12px sans-serif;
			}
 
			.link {
	  			fill: none;
	  			stroke: #ccc;
	  			stroke-width: 2px;
			}
	
    </style>
	</head>

  <body>
  	<!-- load the d3.js library --> 
	<script src="http://d3js.org/d3.v3.min.js"></script>
	
	<!-- Create Tree -->
	<script>
		
		// Data structure		
		var treeDataFlat = [
			{"name": "Master Key", "parent": "null"},
			{"name": "Master Key 1.1", "parent": "Master Key"},
			{"name": "Master Key 1.2", "parent": "Master Key"},
			{"name": "Master Key 2.1", "parent": "Master Key 1.1"},
			{"name": "Master Key 2.2", "parent": "Master Key 1.1"},
			{"name": "Master Key 2.3", "parent": "Master Key 1.2"},
			{"name": "Master Key 2.4", "parent": "Master Key 1.2"},
			{"name": "Key 3.1", "parent": "Master Key 2.1"},
			{"name": "Key 3.2", "parent": "Master Key 2.1"},
			{"name": "Key 3.3", "parent": "Master Key 2.2"},
			{"name": "Key 3.4", "parent": "Master Key 2.2"},
			{"name": "Key 3.5", "parent": "Master Key 2.3"},
			{"name": "Key 3.6", "parent": "Master Key 2.3"},
			{"name": "Key 3.7", "parent": "Master Key 2.4"},
			{"name": "Key 3.8", "parent": "Master Key 2.4"}
		];
		
		// Create teporary data map
		var dataMap = treeDataFlat.reduce(function(map, node) {
 			map[node.name] = node;
 			return map;
		}, {});
		
		// Traverse treeDataFlat and generate hierarchical order
		var treeDataMap = [];
		treeDataFlat.forEach(function(node) {
 			// add to parent
 			var parent = dataMap[node.parent];
 			if (parent) {
  				// create child array if it doesn't exist
  				(parent.children || (parent.children = []))
   				// add node to child array
   				.push(node);
 			} else {
  				// parent is null or missing
  				treeDataMap.push(node);
 			}
		});
		
		// ************** Generate the tree diagram	 *****************
		var margin = {top: 40, right: 120, bottom: 20, left: 120},
			width = 1400 - margin.right - margin.left,
			height = 700 - margin.top - margin.bottom;
			
		var i = 0,
			duration = 800,
			root;
		 
		var tree = d3.layout.tree()
			.size([height, width]);
		 
		var diagonal = d3.svg.diagonal()
			.projection(function(d) { return [d.x, d.y]; });
		 
		var svg = d3.select("body").append("svg")
			.attr("width", width + margin.right + margin.left)
			.attr("height", height + margin.top + margin.bottom)
		  .append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
				 
		root = treeDataMap[0];
		root.x0 = height / 2;
		root.y0 = 0;
					  
		update(root);
		 
		d3.select(self.frameElement).style("height", "500px");
		 
		 
		function update(source) {
		 
		  // Compute the new tree layout.
		  var nodes = tree.nodes(root).reverse(),
			  links = tree.links(nodes);
		 
		  // Normalize for fixed-depth.
		  nodes.forEach(function(d) { d.y = d.depth * 180; });
		 
		  // Update the nodes…
		  var node = svg.selectAll("g.node")
			  .data(nodes, function(d) { return d.id || (d.id = ++i); });
		 
		  // Enter any new nodes at the parent's previous position.
		  var nodeEnter = node.enter().append("g")
			  .attr("class", "node")
			  .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
			  .on("click", click);
		 
		nodeEnter.append("circle")
			.attr("r", 1e-6)
			.style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
		
		// Use an icon as node	
		nodeEnter.append("image")
			.attr("xlink:href", function(d) { return d.icon = "key_blue.png"; })
      		.attr("x", "-24px")
      		.attr("y", "-24px")
      		.attr("width", "48px")
      		.attr("height", "48px");	
      		  
		// Add text to the node  
		nodeEnter.append("text")
		   .attr("y", function(d) { return d.children || d._children ? -18 : 18; })
		   .attr("dy", ".35em")
		   .attr("text-anchor", "middle")
		   .text(function(d) { return d.name; })
		   .style("fill-opacity", 1);
		 
		  // Transition nodes to their new position.
		  var nodeUpdate = node.transition()
			  .duration(duration)
			  .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
		 
		 
		// Changes the icon of the node after collapse	 	  
		nodeUpdate.select("image")
			.attr("xlink:href", function(d){ 
				return d._children ? d.icon = "key_green.png" : d.icon = "key_blue.png"; })
      		.attr("x", "-24px")
      		.attr("y", "-24px")
      		.attr("width", "48px")
      		.attr("height", "48px");
      				
		 
		  nodeUpdate.select("text")
			  .style("fill-opacity", 1);
		 
		  // Transition exiting nodes to the parent's new position.
		  var nodeExit = node.exit().transition()
			  .duration(duration)
			  .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
			  .remove();
		 
		  nodeExit.select("circle")
			  .attr("r", 1e-6);
		 
		  nodeExit.select("text")
			  .style("fill-opacity", 1e-6);
			   
		 
		  // Update the links…
		  var link = svg.selectAll("path.link")
			  .data(links, function(d) { return d.target.id; });
		 
		  // Enter any new links at the parent's previous position.
		  link.enter().insert("path", "g")
			  .attr("class", "link")
			  .attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			  });
		 
		  // Transition links to their new position.
		  link.transition()
			  .duration(duration)
			  .attr("d", diagonal);
		 
		  // Transition exiting nodes to the parent's new position.
		  link.exit().transition()
			  .duration(duration)
			  .attr("d", function(d) {
				var o = {x: source.x, y: source.y};
				return diagonal({source: o, target: o});
			  })
			  .remove();
		 
		  // Stash the old positions for transition.
		  nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
		  });
		}
		 
		// Toggle children on click.
		function click(d) {
		  if (d.children) {
			d._children = d.children;
			d.children = null;
		  } else {
			d.children = d._children;
			d._children = null;
		  }
		  update(d);
		}
		
		
		
	</script>
	
	<!-- Animation to delete key 3.8 -->
	<script>
		function updateKeys(){
						
			// Deletes all nodes and links
			//svg.selectAll('.node').remove();
			//svg.selectAll('.link').remove();
			
						
			treeDataFlatNew = treeDataFlat;
			
			treeDataFlatNew.push({"name": "Master Key 1.2'", "parent": "Master Key"});
			treeDataFlatNew.push({"name": "Master Key 2.4'", "parent": "Master Key 1.2'"});
			treeDataFlatNew.push({"name": "Key 3.8'", "parent": "Master Key 2.4'"});
			
			// Create teporary data map
			var dataMapNew = treeDataFlatNew.reduce(function(map, node) {
	 			map[node.name] = node;
	 			return map;
			}, {});
			
			// Traverse treeDataFlat and generate hierarchical order
			var treeDataMapNew = [];
			treeDataFlatNew.forEach(function(node) {
	 			// add to parent
	 			var parent = dataMapNew[node.parent];
	 			if (parent) {
	  				// create child array if it doesn't exist
	  				(parent.children || (parent.children = []))
	   				// add node to child array
	   				.push(node);
	 			} else {
	  				// parent is null or missing
	  				treeDataMapNew.push(node);
	 			}
			});
			
			root = treeDataMapNew[0];
			root.x0 = height / 2;
			root.y0 = 0;
			
			update(root);
			
		};
		
	</script>
	
	<div id="option">
	    <input name="updateButton" 
	           type="button" 
	           value="Add new key" 
	           onclick="updateKeys()" 
	    />
	</div>
 
  </body>
</html>